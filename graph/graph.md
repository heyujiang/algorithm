### 图的逻辑结构和具体实现

```一个图是由节点和边构成的```

<img src="https://labuladong.gitee.io/algo/images/%e5%9b%be/0.jpg"></img>

```go
type Vertex struct {
     id int
     neighbors []*Vertex                    
}
```

上面的实现是逻辑上的，实际上很少用这个Vertex类实现图，而是用常说的**邻接表**和**邻接矩阵**来实现；
<img src="https://labuladong.gitee.io/algo/images/%e5%9b%be/2.jpeg"></img>

#### 邻接表
    每个节点x的邻居都存在一个列表中，然后把x和这个列表关联起来，这样就可以通过一个节点x找到它的所有相邻节点；

```go
    var graph [][]int
```

#### 邻接矩阵
    邻接矩阵是一个而为布尔数组，如果x和y是相连的，那么就把matrix[x][y]设为true。如果想要找到x的邻居，去扫一圈matrix[x][...]就可以了；

```go
    var martix [][]bool
```

#### 两中存储方式的优劣：
    对于邻接表，好处是占用空间少；但是邻接表无法快速判断两个节点是否相邻；

#### 度（degree）
    在无向图中度就是每个节点相连的边的条数；
    由于有向图的边有方向，所有有向图的中每个节点的度又分为入度和出度；
    
#### 图遍历框架
```go
    var visited []bool //记录已经被遍历过的节点
    var onPath []bool //记录从起点到当前节点的路径

    func traverse(graph Grapth,s int){
        if visited[s] {
            return             
        }
        visited[s] = true  // 经过节点s，标记为已遍历
        onPath[s] = trud //做选择： 标记节点s在路径上
        for _,neighbor := range graph.neighbors(s){
            traverse(graph,neighbor)
        }
        onPath[s] = false //撤销选择：节点s离开路径
    }
```

#### 判断是否有环 
##### DFS解法
    使用visited []bool 记录节点是否访问过，onPath []bool记录访问链路，如果一个节点已经存在访问链路中则证明有环，否则无环；visited减少
    遍历次数；
##### BFS解法 
    核心是计算每个节点的入度，入度为0的节点进入遍历队列，遍历过程中实时计算遍历到的节点的入度，当入度为0时进入遍历队列，遍历结束后count值
    等于节点数量则无环，否则有环；

#### 拓扑排序
##### DFS解法
    在判断环的DFS解法的基础上增加后序遍历结构的记录，将后序遍历记录的结构倒过来就是拓扑排序；
##### BFS解法
    在判断是否有环的BFS解法的基础上，遍历的顺序就是拓扑排序的结果；
    
#### 二分图
二分图的定义：
```二分图的定点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。```

判断二分图的方法为染色法： 在DFS或者BFS过程中依次给相邻的节点染上两种不同的颜色，已经访问的节点判断和相邻的节点颜色是否相同，如果相同则不是二分图，否则是二分图；

#### 并查集（union-find）算法
    并查集算法是一个专门针对【动态连通性】的算法，而且是最小生成树的前置知识；
    
Union-Find算法主要需要实现这三个API：
```go
    type UF interface {
        func union(p,q int)
        func connected(p,q int) bool
        func count() int
    }
```
    
联通是一种等价关系，具有如下三个性质：
- 自反性：节点p和q是联通的。
- 对称性：如果节点p和q联通，那么q和p也联通。
- 传递性：如果节点p和q联通，q和r联通，那么p和r也联通。

使用森林（若干颗树）来表示图的动态连通性，用数组来具体实现这个森林；

#### 最小生成树算法
**什么是最小生成树？**
```text
生成树是指在图中找一颗包含图中所有节点的树；
对于加权图，每条边都有权重，所以每棵生成树都有一个权重和，权重和最小的生成树就是最小生成树。
```
最小生成树，就是图中若干边的集合（mst），需要保证：
- 包含图中所有的节点。
- 形成的结构是树结构（不能有环）。
- 权重和最小。

前两条可以通过并查集来保证；第三点的保证使用了贪心思路：将所有边按照权重大小排序，从权重最小的边开始遍历，如果这条边和mst中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入到mst集合中；否则，这条边不是最小生成树的一部分，不要将它加入mst集合。

最后mst集合中的边就形成了最小生成树。
##### Kruskal最小生成树算法：
    可以认为树的判定算法加上按权重排序的逻辑就是Kruskal算法。

##### Prim最小生成树算法：

#### Dijkstra算法

#### 名流问题